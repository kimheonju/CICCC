24.07.02

knowlege

- do (question, mistake)

- think

- retry


agent

state

search problems

	initial state

	actions - choices that can be made in a state
	actions returns the set of actions that can be executed in state

	transition model - a description of what state results from performing any applicable action in any state
	result returns the state resulting from performing action in state

	state space - the set of all states reachable from the initial state by any sequence of actions

	goal test - way to determine whether a given state is a goal state

	path cost - numerical cost associated with a given path

solution - a sequence of actions that leads from the initial state to a goal state

optimal solution - a solution that has the lowest path cost among all solutions

node 
a data structure that keep track of 
	- a state
	- a parent (node that generated this node)
	- an action (action applied to parent to get node)
	- a path cost (from initial state to node)

Approach
- start with a frontier that contains the initial state
- repeat:
	- if the frontier is empty, then no solution..
	- remove a node from the frontier.
	- if node contains goal state, return the solution.
	- expand node, add resulting nodes to the frontier.

Revised Approach
- start with a frontier that contains the initial state
- start with an empty explored set
- repeat:
	- if the frontier is empty, then no solution..
	- remove a node from the frontier.
	- if node contains goal state, return the solution.
	- add the node to the explored set
	- expand node, add resulting nodes to the frontier if they aren't already in the frontier or the explored set

24.07.03

stack - last-in first-out data type

queue - first-in first-out data type

DFS - depth-first search => stack
search algorithm that always expands the deepest node in the frontier

BFS - breadth-first search => queue
search algorithm that alaways expands the shallowest node in the frontier

24.07.04

uninformed search - search strategy that uses no problem-specific knowledge

informed search - search strategy that uses problem-specific knowledge to find solutions more efficiently

greedy best-first search - search algorithm that expands the node that is closest to the goal, as estimated by a heuristic function
heuristic function => manhattan distance   A = (x1, y1) B = (x2, y2)   ---> | x1 - x2 | + | y1 - y2 |

A* search - search algorithm that expands node with lowest value of g(n) + h(n)
g(n) = cost to reach node
h(n) = estimated cost to goal
optimal of 
- h(n) is admissible (never overestimates the true cost), and
- h(n) is consistent (for every node n and successor n' with step cost c, h(n) â‰¤ h(n') + c)


24.07.05


adversarial search

minimax
max(X) aims to maximize score
min(O) aims to minimize score

Game
so - initial state
player(s) - returns which player to move in state s
actions(s) - returns legal moves in state s
result(s, a) - returns state after action a taken in state s
tetminal(s) - check if state s is a terminal state
utility(s) - final numerical value for terminal state s

given a state s 
	max picks action a in action(s) that produces highest value of min-value(result(s, a))
	min picks action a in action(s) that produces smallest value of max-value(result(s, a))

function max-value(state):
	if terminal(state):
		return utility(state)
	v = -âˆ
	for action in actions(state):
		v = max(v, min-value(result(state, action)))
	return v

function min-value(state):
	if terminal(state):
		return utility(state)
	v = âˆ
	for action in actions(state):
		v = min(v, max-value(result(state, action)))
	return v

depth-limited minimax

evaluation function - function that estimates the expected utiity of the game from a given state

24.07.08

knowledge

knowledge-based agents - agents that reason by operating on internal representations of knowledge

if it didnt rain harry visited hagrid today
harry visited hagrid or dumbledore today, but not both
harry visited dumblefore today
harry did not visit hagrid today
it rained today

logic

sentence - an assertion about the world in a knowledge representation language

propositional logic
proposition symbols - P Q R
logical connnectives - not==ï¿¢ and==âˆ§ or==âˆ¨ implication==â†’ bicnoditional==â†”

not (ï¿¢)
   P           ï¿¢P
false           true
true           false

and (âˆ§)
   P             Q           Pâˆ§Q
false          false          false
false          true          false
true          false          false
true          true           true

or (âˆ¨)
   P             Q           Pâˆ¨Q
false          false          false
false          true          true
true          false          true
true          true          true

implication (â†’)
   P             Q           Pâ†’Q
false          false          true
false          true          true
true          false          false
true          true          true

biconditioanl (â†”)
   P             Q           Pâ†”Q
false          false          true
false          true          false
true          false          false
true          true          true

xor (â“§)
   P             Q           Pâ“§Q
false          false          false
false          true          true
true          false          true
true          true          false

model - assignment of a truth value to every propositional symbol (a "possible world")

knowledge base - a set of sentences known by a knowledge-based agent

entailment - i every model in which sentence Î± is true, sentence Î² is also true

inference - the pocess of deriving new sentences from old ones

inference algorithms

model checking

to determine if KB |= Î±
	enumerate all possible models.
	if in every model where KB is true, Î± is true, then KB entails a
	otherwise, KB does not entail Î±

P: it is Tuesday    Q: it is raining R: harry will go for a run

KB: {Pâˆ§ ï¿¢Q) â†’ R

Query: R

p             Q                R                 KB
false         false           false             false        
false         false           true              false
false         true            false             false
false         true            true              false
true          false           false             false
true          false           true              true
true          true            false             false
true          true            true              false

24.07.09

clue

people     rooms     weapons
mustard   ballroom  knife
plum       kitchen     revolver
scarlet     library      wrench

propositinal symbols


musted or plum or scarlet
ballroom or kitchen or library
knife or revolver or wrench

not plum
not musted or not library or not revolver

24.07.10

inference rules

modus ponens
and elimination
double negation elimination

P -> Q == ï¿¢P âˆ¨ Q
P -> Q !== Q -> P
Î± <-> Î² == (Î± -> Î²) âˆ§ (Î² -> Î±)
ï¿¢(Î± âˆ§ Î²) == ï¿¢Î± âˆ¨ ï¿¢Î²
ï¿¢(Î± âˆ¨ Î²) == ï¿¢Î± âˆ§ ï¿¢Î² 
(Î± âˆ§ (Î² âˆ¨ Î³)) == (Î± âˆ§ Î²) âˆ¨ (Î± âˆ§ Î³)
(Î± âˆ¨ (Î² âˆ§ Î³)) == (Î± âˆ¨ Î²) âˆ§ (Î± âˆ¨ Î³)

theorem proving

	initial state: starting knowledge base
	actions: inference rules
	transition model: nwe knowledge base after inference
	goal test: check statement we're trying to prove
	path cost finction: number of steps in proof


Resolution
opposite things are cancel each other

clause
a disjunction(= OR) of literals(symbols or not symbols) / a bunch of literals 
e.g. P âˆ¨ Q âˆ¨ R

conjunctive normal form(CNF)
logical sentence that is a conjunction(= AND) of clauses
e.g. (A âˆ¨ B âˆ¨ C) âˆ§ (D âˆ¨ ï¿¢E) âˆ§ (F âˆ¨ G)

Conversion to CNF
- Eliminate biconditionals
   - turn (Î± <-> Î²) into (Î± -> Î²) âˆ§ (Î² -> Î±)
- Eliminate implications
   - turn Î± -> Î² == ï¿¢Î± âˆ¨ Î²
- Move ï¿¢ inwards using De Morgan's Laws
   - e.g. turn ï¿¢(Î± âˆ§ Î²) == ï¿¢Î± âˆ¨ ï¿¢Î²
- Use distribute law to Distribute âˆ¨ wherever possible
   - to put âˆ¨ inside and âˆ§ outside 
CNFì— ëŒ€í•œ ì„¤ëª…ì„ ë‚˜íƒ€ëƒ„ 
ë²•ì¹™ì„ ì‚¬ìš©í•´ì„œ ìµœì¢…ì ì¸ CNFê°€ ë‚˜ì˜´

24.07.11

Inference(ì¶”ë¡ ) by Resolution(ê²°ì‹¬)
ï¿¢âˆ¨âˆ§ Î± Î²
P âˆ¨ Q âˆ¨ S + ï¿¢P âˆ¨ R âˆ¨ S == (Q âˆ¨ R âˆ¨ S)

P + ï¿¢P == ( ) Empty -> False

to determine(ê²°ì •í•˜ë‹¤) if KB |= Î± :
	check if (KB âˆ§ ï¿¢Î±) is a contradiction(ëª¨ìˆœ)?
	if so, then KB |= Î± .
	otherwise, no entailment(í•œì •)

to determine if KB |= Î± :
	convert(KB âˆ§ ï¿¢Î±) to Conjunctive Normal Form
	Keep checking to see if we can use resolution to produce(ìƒì‚°) a new clause(ì¡°í•­)
		if ever we produce the empty clause (equivalent(ë™ë“±í•œ) to False), we have a contradiction, and KB |= Î±
		Otherwise, if we can't add new clauses, no entailment

Dose (A âˆ¨ B) âˆ§ (ï¿¢B âˆ¨ C) âˆ§ (ï¿¢C) entail A?
	(A âˆ¨ B) âˆ§ (ï¿¢B âˆ¨ C) âˆ§ (ï¿¢C) âˆ§ (ï¿¢A)
	(A âˆ¨ B) âˆ§ (ï¿¢B âˆ¨ C) âˆ§ (ï¿¢C) âˆ§ (ï¿¢A) = resolve(í•´ê²° each other) ==> (A) âˆ§ (ï¿¢A) == ( ) Empty -> False


First - Order Logic 
	Constant Symbol | Predicate Symbol(Function)
	Minerva		Person
	Pomana		House
	Horce			
	...

Universal Quantification
âˆ€x. BelongsTo(x, Gryffindor) -> BelongsTo(x, Hufflepuff)
== for all objects x, if x belongs to gryffindor, then x does not belong to hufflepuff.

ï¿¢âˆ¨âˆ§
Existential Quantification
âˆƒx. House(x) âˆ§ BelongsTo(Minerva, x)
== there exists an object x such that x is a house and Minerva belongs to x.
Minerva Belongs to a house

âˆ€x. Person(x) -> âˆƒy. House(y) and BelongsTo(x,y))
== For all objects x, if x is a person, then there exists an object y such that y is a house and x belongs to y.
Every person belongs to house

Knowledge

24.07.12

Uncertainty(ë¶ˆì•ˆì •)

Probability(í™•ë¥ )

Possible Worlds
P(Ï‰) == probability of omega
0 â‰¤ P(Ï‰) â‰¤ 1

   âˆ‘   P(Ï‰) = 1
Ï‰âˆˆÎ©

P(SUM to 12) = 1/36
P(SUM to 7) = 6/36 = 1/6

unconditional(ë¹„ì¡°ê±´ë¶€) probability
degree of belief in a proposition(ì œì˜) in the absence(ì—†ìŒ) of any other evidence(ì¦ê±°)

conditional(ì¡°ê±´ë¶€) probability
degree of belief in a proposition given some exvidence that has already been revealed(ë³´ì´ëŠ”)
P (a | b) -> a given b

P(a | b) = P(a âˆ§ b) / P(b)
P(a âˆ§ b) = P(b)P(a | b) = P(a)P(b | a)

random variable
a variable in probability theory(ì´ë¡ ) with a domain of possible values it can take on

probability distribution
P(Flight = on time) = 0.6
P(Flight = in delayed) = 0.3
P(Flight = in cancelled) = 0.1
P(flight) = <0.6, 0.3, 0.1>

independence(ë…ë¦½)
the knowledge that one event occurs(ë°œìƒí•˜ë‹¤) does not affect the probability of the other event
P(a âˆ§ b) = P(a)P(b | a)
P(a âˆ§ b) = P(a)P(b)

Bayes' Rule
P(b | a) = P(b)P(a | b)/P(a)

24.07.15

Joint Probability
ï¿¢âˆ¨âˆ§ Î± Î²


AM - C= cloud 0.4 | C = ï¿¢ cloud 0.6 
PM - R = rain 0.1   | R = ï¿¢ rain 0.9

             R = rain  R = ï¿¢ rain
C = cloud      0.08            0.32
C = ï¿¢  cloud 0.02            0.58

P(rain) = Constant Value, So change 1/P(rain) -> Î±
P(C, rain) = Joint Probability
P(C | rain) = Conditional Probability

P(C | rain)
P(C | rain) = P(C, rain) / P(rain) = Î± P(C, rain)  
		= Î±<0.08, 0.02> = <0.8, 0.2>

Conditional Probability is Propotionally equal to Joint Probability
ï¿¢âˆ¨âˆ§ Î± Î²
Probability Rule
	- Nagation == P(ï¿¢a) = 1 - P(a)
	- Inclusion-Exclusion == P(aâˆ¨b) = P(a) + P(b) - P(aâˆ§b)
	- Marginalization == P(a) = P(a, b) + P(a, ï¿¢b)
	  P(X = xi) = âˆ‘ P(X = xi, Y=yj)
			 j
	  ex) y= { y1, y2, y3, y4}
	  P(a) = P(x, y1) + P(x, y2) + P(x, y3) + P(x, y4) 
         			R = rain  R = ï¿¢ rain
		C = cloud      0.08            0.32
		C = ï¿¢  cloud 0.02            0.58
		P(C = cloud) = P(C = cloud, R = rain) + P(C = cloud, R = ï¿¢rain) = 0.08 + 0.32 = 0.4
		Joint Prob. calculate -> Unconditional Prob.
	- Conditioning == P(a) = P(a | b)P(b) + (a | ï¿¢b)P(ï¿¢b)
		Conditional Prob. calculate -> Unconditional Prob.

Bayersian network
data srtucture that represents(ë‚˜íƒ€ë‚´ëŠ”) the dependencies among random variables
 - directed graph (node, edge)
 - each node represents a random variable
 - arrow form X to Y means X is a parent of Y
 - each node X has probability distribution P(X | parents(X))

			Rain
		{none, light, heavy}
		|			|
		âˆ¨			|
	Maintenance(ì§€ì†)		|
	   {yes, no}			|
		|			|
		âˆ¨			âˆ¨
			Train
		{on time, 	delayed}
			|
			âˆ¨
		Appointment
		{attend, miss}

Rain {none, light, heavy}
	0.7     0.2    0.1

			Rain
		{none, light, heavy}
		|			|
		âˆ¨			|
	Maintenance		|
	   {yes, no}			|
		|			|

Rain		yes		no
none		0.4		0.6
light		0.2		0.8
heavy		0.1		0.9

			Rain
		{none, light, heavy}
		|			|
		âˆ¨			|
	Maintenance		|
	   {yes, no}			|
		|			|
		âˆ¨			âˆ¨
			Train
		{on time, 	delayed}
			|

R		M		on time		delayed
none		yes		0.8			0.2
none		no		0.9			0.1
light		yes		0.6			0.4
light		no		0.7			0.3
heavy		yes		0.4			0.6
heavy		no		0.5			0.5


			Train
		{on time, 	delayed}
			|
			âˆ¨
		Appointment
		{attend, miss}

T		attend			miss
on time	0.9			0.1
miss		0.6			0.4

------------------------------------------------------

Inference
 - Query X: variable for which to compute distribution
 - Evidence(ì¦ê±°) variables E: observed(ê´€ì°°) variables for event e
 - Hidden variables Y: non-evidence, non=query variable.

 - Goal: Calculate P(X | e)

P(Appointment | light, no) = Î± P(Appioint, light, no) = Î± [P(Appoinment, light, no, on time) +P(Appoinment, light, no, delayed)]

Appointment - Query
light, no - Evidence
Train(on time, delayed) - Hidden
Hiddenì´ í•˜ë‚˜ë¼ì„œ ê²°ê³¼ëŠ” 2ê°œë§Œ ë‚˜ì˜¤ëŠ”ê±°ì„ ë‘ê°€ì§€ ìƒí™©ì´ë‹ˆê¹Œ í•˜ì§€ë§Œ Hiddenì´ ë‘ê°œë¼ë©´ ê²°ê³¼ëŠ” 4ê°œ

Inference by Enumeration
P(X | e) = Î± P(X, e) = Î± âˆ‘ P(X, e, y)
			      y
X is the query variable.
e is the evidence
y ranges over values of hidden vaiables
Î± normalizes the result


24.07.16

Approximate(ê·¼ì‚¬) Inference
ï¿¢âˆ¨âˆ§ Î± Î²

Sampling(Technique) for multiple time

P(Rain=light | Train = on time)? - Conditional Prob.
P(Train = on time)? - Unconditional Prob.

Rejection(ê¸°ê°) Sampling
	Likelihood Weighting
	 - Start by fixing the values for evidence variables
 	 - Sample the non-evidence variables using conditional probabilities in the Bayesian Network
	 - Weight each sample by its likelihood: the probability of all of the evidence

24.07.17

Uncertainty(ë¶ˆí™•ì‹¤ì„±) over Time

Xt : Weather at time t

Markov assumption(ê°€ì •)
the assumption that current state depends(ì˜ì§€í•˜ë‹¤) on only a finite(ìœ í•œí•œ) fixed number of previous(ì´ì „) states

Markov chain
a sequence of random variables where the distribution of each variable follows the markov assumption

Sensor Models

Hidden State		Observation(ê´€ì°°)

robot's position		robot's sensor data
words spoken		audio wavwforms
user engagement		website or app analytics		
weather			umbrella

Hidden Markov Models
a Markov model for a systme with hidden states that genaerate(ë°œìƒì‹œí‚¤ë‹¤) some observed event

sensor Markov assumption
the assumption that the evidence variable depends only the corresponding(dì¼ì¹˜í•˜ëŠ”) state

Task				Definition

Filtering			given observations from start until now, calculate distribution for current state
prediction			given observations from start until now, calculate distribution for a future state
smoothing			given observations from start until now, calculate distribution for past(ê³¼ê±°) state
most likely explanation	given observations from start until now, calculate most likely sequence of states

Optimization
choosing the best option from a set of options

local search
search algorithms that maintain(ìœ ì§€) a single node and searches by moving to a neighboring node


state-space landscape
global-maximum == objective function
global-minimum == cost function
curren state --> move on to a 2 neighboring state

Hill climing
function hill-climb(problem):
	current = initial state of problem
	repeat:
		neighbor = highest value neighbor of current
		if neighbor not better than current:
			return current 
		current = neighbor 

Hill Climbing Variants
	Variant						Definition
	steepest(ê°€ì¥ ê°€íŒŒë¥¸)-ascent(ì–¸ë•)		choose the highest-valued neighbor
	stochastic(í™•ë¥ ì ì¸)				choose randomly from higher-valued neighbors
	first-choice						choose the first higher-valued neighbor
	random-restart					conduct(ì‹¤ì‹œ) hill climbing multiple times
	local beam search					chooses the k highest-valued neighbors

24.07.18

Simulated Annealing

â€¢ Early on, higher "temperature": more likely to accept neighbors that are worse than current state
â€¢ Later on, lower "temperature": less likely to accept neighbors that are worse than current state

function SIMULATED-ANNEALING(problem, max):
	current - initial state of problem
	for t = 1 to max:
		T = TEMPERATURE(t)
		neighbor = random neighbor of current
		Î”E = how much better neighbor is than current
		if Î”E > 0:
			current = neighbor
		with probability eÎ”E/T set current = neighbor
	return current
eÎ”E/T == 0,1 == Tê°€ ë†’ì•„ì§ˆìˆ˜ë¡ 1ì— ê°€ê¹Œì›Œì§€ê³  ë‚®ì•„ì§ˆìˆ˜ë¡ 0ì— ê°€ê¹Œì›Œì§

Traveling Salesman Problem
Linear Programming
â€¢ Minimize a cost function c1x1 + c2x2 + ... + cnxn.
â€¢ With constraints of form a1x1 + a2x2 + ... + anxn â‰¤ b 
  or of form a1x1 + a2x2 + ... + anxn = b
â€¢ With bounds for each variable li < xi â‰¤ ui

Linear Programming Example
â€¢ Two machines X1 and X2. X1 costs $50/houe to run, X2 costs $80/hour to run. Goal is to minimize cost.
â€¢ X1 requires 5 units of labor per hour. X2 requires 2 units of labor per hour. Total of 20 units of labor to spend.
â€¢ X1 produces 10 units of output per hour. X2 produces 12 units of output per hour. Company needs 90 units of output.

Cost Function : 50x1 + 80x2
Constraint : 5x1 + 2x2 â‰¤ 20
Constraint : 10x1 + 12x2 â‰¥ 90 ==> (-10x1) + (-12x2) â‰¤ (-90)

Linear Programming Algorithms
 - Simplex

 - Interior - Point

24.07.19

Constraint(ì œì•½ì¡°ê±´) Satisfaction(ë§Œì¡±) Problem
 - Set of variables { X1, X2, ... Xn }
 - Set of domains for each variable { D1, D2, ... Dn }
 - Set of constraints C

ex)
Variables - { A, B, C, D, E, F, G }
Domains - { Monday, Tuesday, Wedesday } for each variable
Constraints - { A â‰  B }

hard constraints
constraint that must be satisfied in a correct solution

soft constraints
constraint that express some notion of which colutions are preferred over others

unary constraint(ë‹¨í•­ ì œì•½)
constraint involving (í¬í•¨í•˜ë‹¤) only one variable
{ A â‰  Monday }

binary constraint(ì´í•­ ì œì•½)
constraint involving two variables
{ A â‰  B }

node consistency
when all the values in a variable's domain satisfy the variable's unary constraints

arc consistency
when all the values in a variable's domain satisfy the variable's binary constraints
To make X arc-consistent with respect to Y, remove elements from X's domain until every choice for X has a possible choice for Y

function REVISE(csp, X, Y):
	revised = False
	for x in X.domain:
		if no y in Y.domain satisfies constraint for (X, Y):
			delete x from X.domain
			revised = ture
	return revised

function AC-3(csp):
	queue = all arcs in csp
	while queue non-empty:
	(X, Y) = DEQUEUE(queue)
	if REVISE(csp, X, Y):
		if size of X.domain == 0:
			return false
		for each Z in X.neighbors - {X}:
			ENQUEUE(queue, (Z,X))
	return true

CSPs as Search Problems
â€¢ initial state: empty assignment (no variables)
â€¢ actions: add a {variable = value} to assignment
â€¢ transition model: shows how adding an assignment changes the assignment
â€¢ goal test: check if all variables assigned and constraints all satisfied
â€¢ path cost function: all paths have same cost


Backtracking Search
function BACKTRACK(assignment, csp):
	if assignment complete: return assignment
	var = SELECT-UNASSIGNED-VAR(assignment, csp)
	for value in DOMAIN-VALUES(var, assignment, csp):
		if value consistent with assignment:
			add {var = value} to assignment
			result = BACKTRACK(assignment, csp)
			if result â‰  failure:return result
		remove {var = value} from assignment
	return failure

24.07.22

maintaining arc-consistency
algorithm for enforcing arc-consistency every time we make a new assignment
when we make a new assignment to X, calls AC-3, starting with a queue of all arcs (Y, X) where Y is a neighbor of X

function BACKTRACK(assignment, csp):
	if assignment complete: return assignment
		var = SELECT-UNASSIGNED-VAR(assignment, csp)
		for value in DOMAIN-VALUES(var, assignment, csp):
			if value consistent with assignment:
				add {var = value} to assignment
				inferences - INFERENCE(assignment, sp)
				if inferences â‰  failure: add inferences to assignment
				result = BACKTRACK(assignment, esp)
				if result â‰  failure: return result
			remove {var = value} and inferences from assignment
		return failure

SELECT-UNASSIGNED-VAR
 - minimum remaining values (MRV) heuristic : selelct the variable that has the smallest domain
 - degree heuristic : select the variable that has the highest degree (highest degree has many neighbors)

DOMAIN-VALUES
 - least-constraining values heuristic : return variables in order by number of choices that are ruled out fo neighboring variables
	 - try least-constraining values first


============================================
Learning
Supervised Learning
given a data set of input-output pairs, learn a function to map inputs to outputs

Classification
supervised learning task of learning a function mapping an input point to a discrete category

f(humidity, pressure)
	f(93, 999.7) = Rain
	f(49, 1015.5) = No Rain
	f(79, 1031.1) = No Rain
h(numidity, pressure)

nearest-neighbor classification
algorithm that, given an input, chosses the class of the nearest data point to that input

K-nearest-neighbor classification
algorithm that, given an input, chosses the most common class out of the K nearest data points to that input

Linear Regression
x1 = humidity
x2 = pressure

h(x1, x2) = 	Rain if w0 + w1x1 + w2x2 â‰¥ 0
		No Rain otherwise
 ==

h(x1, x2) = 	1 if w0 + w1x1 + w2x2 â‰¥ 0
		0 otherwise

Weight Vector w : (w0, w1, w2)
Input Vector x : (1, x1, x2)
w * x : w0 + w1x1 + w2x2

h(x) = 	1 if w *x â‰¥ 0
		0 otherwise

perceptron learning rule
Given data point (x,y), update each weight according to:

wi = wi + Î±(y - hw(x)) * xi
==
wi = wi + Î±(actual value - estimate) xi

24.07.23

perceptron learning rule
Given data point (x,y), update each weight according to:

wi = wi + Î±(y - hw(x)) * xi
==
wi = wi + Î±(actual value - estimate) xi

1. data		-- data point -> rain estimate
			-- label	 -> rain actual

2. train data 		-- perceopron : updating weight
			-- k-nearest, neighbor --> creat a model
			-- SVM

3. test the model

4. use the model to generalize and classify

h(x1, x2) = 	1 if w0 + w1x1 + w2x2 â‰¥ 0
		0 otherwise

hard threshold --> 1 or 0 
soft thereshold --> flexible
SVM (Support Vector Machines)
maxinum margin separator
boundary that maximizes the distance between any of the data points

regression
supervised learning task of learning a function mapping an input point to a continuous value

f (advertising)
	f(1200) = 5800
	f(2800) = 13400
	f(1800) = 8400
h (advertising)

Evaluating Hypotheses

loss function
function that expresses(í‘œí˜„) how poorly our hypothesis(ê°€ì„¤) performs(ìˆ˜í–‰)

0-1 loss function
L(catual, predicted) =
	0 if actual = predicted,
	1otherwise

L1 loss function
L(actual, predicted) = | actual - predicted |

L2 loss function
L(catual, predicred) = (actual - predicted)**2

cost === loss

overfitting
a model that fits too closely to a particular data set and therefore may fail to generalize to future data
cost(h) = loss(h) + Î» complexity(h)

regularzation
penalizing(ë¶ˆì´ìµ) hypotheses that are more complex to favor simpler, more general hypotheses
cost(h) = loss(h) + Î» complexity(h) ë³µì¡ì„±ì´ ì¦ê°€í•˜ë©´ ê·¸ë§Œí¼ì˜ ì†ì‹¤ë„ ì¦ê°€í•œë‹¤

holdout cross-validation
splitting data into a training set and a test set, 
such that learning happens on the training set and is evaluated on the test set

k-fold cross-validation
splitting data into k sets, and experimenting(ì‹¤í—˜) k times, 
using each set as a test set once, and using remaining data as training set

scikit-learn

Reinforcement Learning
given a set of rewards or punishments(ë²Œ), learn what actions to take in the future

		Environment

 |||		âˆ§ action	|||
 âˆ¨ state	|||		âˆ¨ reward

		agent

Markov Decision Process
model for decision-making, representing states, actions, and their rewards
 - Set of states S
 - Set of actions ACTIONS(s)
 - Transition model P(s' | s, a)
 - Reward Finction R(s, a, s')

24.07.24

Q-learning
method for learning a functino Q(s, a), estimate of the valur of performing action a in state s
 - Start with Q(s,a) =0 for all s,a
 - Every time we  take an action a in state s and observe a reward r, we update:
Q(s,a) â† Q(s,a) + Î±(new value estimate - old value estimate)
Q(s,a) â† Q(s,a) + Î±((r + MAXa' Q(s', a')) - Q(s, a))
Q(s,a) â† Q(s,a) + Î±((r + future reward estimate) - Q(s, a))
Q(s,a) â† Q(s,a) + Î±((r + Î³MAXa' Q(s', a')) - Q(s, a))


Q-learning Overview
 - Start with Q(s,a) =0 for all s,a
 - When we taken an action and receive a reward:
	- Estimate the value of Q(s.a) based on current reward and expected future rewards
	 - Update Q(s,a) to take into account old estimate as well as our new estimate

Greedy Decision-Making
 - When in state s, choose action a with highest Q(s,a)

Explore(íƒí—˜, ì¡°ì‚¬) vs Exploit(ì´ìš©, ê°œì²™)

Îµ-greedy
 - Set Îµ equal to how often we want to move randomly.
 - With pobability 1 - Îµ, choose estimated best move.

function approximation
approximating(ê·¼ì ‘í•œ) Q(s, a), often by a function combining various features, rather than storing one value for exery state-action pair

Unsupervised Learning
given input data without any additional feedback, learn patterns

Clustering
organizing(êµ¬ì„±) a set of objects into group in such a way taht similar objects tend to be in the same group

Some Clustering Applications
 - Genetic research
 - IMage segmentation
 - Market search

K-means clustering
algorithm for clustering data based on repeatedly assigning(í• ë‹¹) points to clustes and updating those cluster's centers


24.07.25

artificial neural network
mathematical model for learning inspired by biological neural networks

ANN
 - Model mathematival function from inputs to outputs based on the structure and parameters of the network
 - Allows of learning the network's parameters based on data

h(x1, x2) = w0 + w1x1 + w2x2

step function g(x) = 1 if x â‰¥ 0, else 0
logistic sigmoid g(x) = e**x/ e**x + 1
rectified linear unit (ReLU) g(x) = max(0, x)
h(x1, x2) = g(w0 + w1x1 + w2x2)

Gradient Descent
algorithm for minimizing loss when training neural network
 - Start with a random choice of weights.
 - Repeat :
	 - Calculate the gradient based on all data points :
	   direction that will lead to decreasing loss.
	 - Update weights according to the gradient.

Stochastic Gradient Descent
 - Start with a random choice of weights.
 - Repeat :
	 - Calculate the gradient based on one data points :
	   direction that will lead to decreasing loss.
	 - Update weights according to the gradient.

Mini-Batch Gradient Descent
 - Start with a random choice of weights.
 - Repeat :
	 - Calculate the gradient based on one small batch :
	   direction that will lead to decreasing loss.
	 - Update weights according to the gradient.

Perceptron
 - Only capable(ìœ ëŠ¥í•œ) of learning linearly separable(ë¶„ë¦¬í•  ìˆ˜ ìˆëŠ”) decision(ê²°ì •) boundary.

Multilayer neural network
artificial neural network with an input layer, an output layer, and at least on hidden layer
hidden layer is  random weights

backpropagation(ì—­ì „íŒŒ)
algorithm for training neural networks with hidden layer

 - Start with a random choice of weights.
 - Repeat :
	 - Calculate error for output layer :
	 - For each layer, starting with output layer, and moving inwards towards earliest hidden layer :
		 - Propagate error back one layer.
		 - Update weights.

Deep Neural Networks
neural network with multiple hidden layers

dropout
temporarily(ì¼ì‹œì ìœ¼ë¡œ) removing units -- selected at random -- from a neural network to prevent(ë§‰ë‹¤) over-reliance(ê³¼ë„í•œ ì˜ì¡´) on certain(íŠ¹ì •) units

Tensorflow

24.07.26

Computer wision
computational(ê³„ì‚°) methods for analyzing and understanding digital images

Image Convolution
applying a filiter that adds each pixel value of an image to its neighbors, weighted according to a kernel matrix

pooling
reducing the size of an input by sampling from regions in the input

max-pooling
pooling by choosing the maximum value in each region

convolutional neural network
neural network that use convolution, usually for analyzing images

feed-forward neural network
neural network that has connections only un ine direction

recurrent neural network
neural network that generates output that feeds back into its own inputs

24.07.29

Natural Language Processing

 - automatic summarization
 - information extraction
 - machine reanslation
 - question answering
 - text classification

Syntax == structure

Sentence

formal grammar
a system of rules for generating sentences in a language

Context-Free Grammar(CFG)

N-gram
a contiguous sequence of n items from a sample of text

Markov chain

bag-of-words model
model that represents text as an unordered collection of words

Naive Bayes
P(A|B) = P(B|A) * P(A) / P(B)

P(Positive)
P(Nagative)

P(ğŸ˜Š| "my grandson loved it" ) equal to P( "my grandson loved it" | ğŸ˜Š ) P( ğŸ˜Š ) / P( "my grandson loved it" )

P(ğŸ˜Š | "my", "grandson", "loved", "it" ) proportional to P(ğŸ˜Š, "my", "grandson", "loved", "it" )


P( ğŸ˜Š ) = number of positive samples / all samples

additive smoothing
adding a value Î± to each value in our
distribution to smooth the data

laplace smoothing
adding i to each value in our distribution:
pretending we've seen each value one more time than we actually have

24.07.30

Word Representation

one-hot-representation
representation of meaning as a vactor with a single 1, and with other values as 0

distributed representation
representation of meaning distributed across multiple values

word2vec
model for generating word vectors

Neural Network

Attention